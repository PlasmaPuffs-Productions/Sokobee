<!DOCTYPE html>
<html lang="en">
        <head>
                <meta charset="UTF-8">
                <title>Level Editor</title>
                <style>
                        * {
                                box-sizing: border-box;
                                font-family: monospace;
                                color: white;
                        }

                        html, body {
                                margin: 0;
                                padding: 0;
                                height: 100%;
                                overflow: hidden;
                        }

                        #container {
                                position: relative;
                                width: 100vw;
                                height: 100vh;
                        }

                        canvas {
                                display: block;
                                width: 100%;
                                height: 100%;
                                border: 1px solid black;
                        }

                        #export-controls {
                                position: absolute;
                                top: 10px;
                                right: 10px;
                                z-index: 10;
                                display: flex;
                                gap: 8px;
                                align-items: center;
                                background-color: rgba(0, 0, 0, 0.75);
                                padding: 10px 16px;
                                border-radius: 5px;
                        }

                        #export-controls input[type="number"] {
                                width: 48px;
                                font-size: 15px;
                                padding: 2px 4px;
                                border-radius: 2.5px;
                                border: none;
                                background-color: rgba(255, 255, 255, 0.25);
                        }

                        #export-button {
                                padding: 8px 12px;
                                background-color: #00AA00;
                                font-weight: bold;
                                border: none;
                                border-radius: 2.5px;
                                cursor: pointer;
                        }
                </style>
        </head>
        <body>
                <div id="container">
                        <canvas id="hexCanvas"></canvas>
                        <div id="export-controls">
                                <label>
                                        Columns:
                                        <input id="columns-input" type="number" min="1" max="30" value="10"/>
                                </label>
                                <div style="width: 5px;"></div>
                                <label>
                                        Rows:
                                        <input id="rows-input" type="number" min="1" max="30" value="10"/>
                                </label>
                                <div style="width: 20px;"></div>
                                <button id="export-button">Export JSON</button>
                        </div>
                </div>

                <script>
                        const DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;

                        const columnsInput = document.getElementById("columns-input");
                        const rowsInput    = document.getElementById("rows-input");
                        const exportButton = document.getElementById("export-button");
                        const container    = document.getElementById("container");
                        const canvas       = document.getElementById("hexCanvas");
                        const context      = canvas.getContext("2d");

                        let gridRows;
                        let gridColumns;
                        let hexagonRadius;
                        let gridOffsetX;
                        let gridOffsetY;
                        let tiles;

                        function getHexagonPosition(column, row) {
                                return {
                                        x: hexagonRadius * 3 / 2 * column + gridOffsetX,
                                        y: hexagonRadius * Math.sqrt(3) * (row + 0.5 * (column & 1)) + gridOffsetY
                                };
                        }

                        function getHexagonTile(x, y) {
                                for (let column = 0; column < gridColumns; ++column) {
                                        for (let row = 0; row < gridRows; ++row) {
                                                const hexagon = getHexagonPosition(column, row);

                                                const vertices = [];
                                                for (let index = 0; index < 6; ++index) {
                                                        const angle = index * 60 * Math.PI / 180;
                                                        vertices.push({
                                                                x: hexagon.x + hexagonRadius * Math.cos(angle),
                                                                y: hexagon.y + hexagonRadius * Math.sin(angle)
                                                        });
                                                }

                                                let inside = false;
                                                for (let thisIndex = 0, nextIndex = vertices.length - 1; thisIndex < vertices.length; nextIndex = thisIndex++) {
                                                        const {x: x1, y: y1} = vertices[thisIndex];
                                                        const {x: x2, y: y2} = vertices[nextIndex];
                                                        if (((y1 > y) !== (y2 > y)) && (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1)) {
                                                                inside = !inside;
                                                        }
                                                }

                                                if (!inside) {
                                                        continue;
                                                }

                                                return {column, row};
                                        }
                                }

                                return null;
                        }

                        function drawGrid() {
                                context.fillStyle = "rgb(50, 35, 15)";
                                context.fillRect(0, 0, canvas.width, canvas.height);

                                for (let column = 0; column < gridColumns; ++column) {
                                        for (let row = 0; row < gridRows; ++row) {
                                                const tileIndex = column + row * gridColumns;
                                                const {x, y} = getHexagonPosition(column, row);
                                                let tileScale = 1.0;

                                                switch (tiles[tileIndex]) {
                                                        case 0: {
                                                                tileScale = 0.75;
                                                                context.setLineDash([5, 5]);
                                                                context.fillStyle = "transparent";
                                                                context.lineWidth = hexagonRadius / 20;
                                                                context.strokeStyle = "rgba(255, 255, 255, 0.5)";
                                                                break;
                                                        }

                                                        case 1: {
                                                                context.setLineDash([]);
                                                                context.fillStyle = "rgb(240, 170, 35)";
                                                                context.lineWidth = hexagonRadius / 5;
                                                                context.strokeStyle = "rgb(255, 220, 120)";
                                                                break;
                                                        }

                                                        case 2: {
                                                                context.setLineDash([]);
                                                                context.fillStyle = "rgb(190, 140, 35)";
                                                                context.lineWidth = hexagonRadius / 5;
                                                                context.strokeStyle = "rgb(255, 220, 120)";
                                                                break;
                                                        }
                                                }

                                                context.beginPath();
                                                for (let index = 0; index < 6; ++index) {
                                                        const angle = index * 60 * Math.PI / 180;
                                                        context[index === 0 ? "moveTo" : "lineTo"](
                                                                x + tileScale * hexagonRadius * Math.cos(angle),
                                                                y + tileScale * hexagonRadius * Math.sin(angle)
                                                        );
                                                }

                                                context.closePath();
                                                context.fill();
                                                context.stroke();
                                        }
                                }
                        }

                        function resizeCanvas() {
                                const rectangle = container.getBoundingClientRect();
                                canvas.width    = rectangle.width  * DEVICE_PIXEL_RATIO;
                                canvas.height   = rectangle.height * DEVICE_PIXEL_RATIO;
                                context.setTransform(DEVICE_PIXEL_RATIO, 0, 0, DEVICE_PIXEL_RATIO, 0, 0);

                                const padding         = Math.min(rectangle.width, rectangle.height) / 20;
                                const availableWidth  = rectangle.width  - padding * 2;
                                const availableHeight = rectangle.height - padding * 2;

                                const maximumHexagonRadiusFromWidth  = availableWidth  / (1.5 * (gridColumns - 1) + 2);
                                const maximumHexagonRadiusFromHeight = availableHeight / (Math.sqrt(3) * (gridRows + 0.5));
                                hexagonRadius = Math.min(maximumHexagonRadiusFromWidth, maximumHexagonRadiusFromHeight);

                                const gridWidth  = hexagonRadius * (1.5 * (gridColumns - 1) + 2);
                                const gridHeight = hexagonRadius * Math.sqrt(3) * (gridRows + 0.5);

                                gridOffsetX = padding + (availableWidth  - gridWidth)  / 2 + hexagonRadius;
                                gridOffsetY = padding + (availableHeight - gridHeight) / 2 + hexagonRadius * Math.sqrt(3) / 2;

                                drawGrid();
                        }

                        window.addEventListener("resize", resizeCanvas);

                        function gridSizeChanged() {
                                const columns = parseInt(columnsInput.value, 10);
                                const rows    = parseInt(rowsInput   .value, 10);
                                if (Number.isNaN(columns) || Number.isNaN(rows)) {
                                        columnsInput.value = gridColumns;
                                        rowsInput.value = gridRows;
                                        return;
                                }

                                columnsInput.value = gridColumns = Math.min(Math.max(columns, 2), 20);
                                rowsInput   .value = gridRows    = Math.min(Math.max(rows,    2), 20);

                                tiles = Array(gridColumns * gridRows);
                                tiles.fill(0);

                                resizeCanvas();
                        }

                        columnsInput.addEventListener("change", gridSizeChanged);
                        rowsInput   .addEventListener("change", gridSizeChanged);

                        canvas.addEventListener("click", event => {
                                const rectangle = canvas.getBoundingClientRect();
                                const x = event.clientX - rectangle.left;
                                const y = event.clientY - rectangle.top;
                                const hexagon = getHexagonTile(x, y);
                                if (hexagon === null) {
                                        return;
                                }

                                const tileIndex = hexagon.column + hexagon.row * gridColumns;
                                tiles[tileIndex] = (tiles[tileIndex] + 1) % 3;
                                drawGrid();
                        });

                        exportButton.addEventListener("click", _ => {
                                const json = JSON.stringify({
                                        columns:  gridColumns,
                                        rows:     gridRows,
                                        tiles,
                                        entities: []
                                }, null, 8);

                                const blob = new Blob([json], {type: "application/json"});
                                const url = URL.createObjectURL(blob);

                                const link = document.createElement("a");
                                link.href = url;
                                link.download = "Level.json";
                                link.click();

                                URL.revokeObjectURL(url);
                        });

                        gridSizeChanged();
                </script>
        </body>
</html>